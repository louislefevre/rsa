package keys;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Random;

public final class RSAKeyGenerator
{
    public static final short BIT_LENGTH = 2048;
    public static final int[] FERMAT_NUMBERS = {65537, 257, 17, 5, 3};

    public static KeyPair generateKeyPair()
    {
        BigInteger primeP = generatePrime(BIT_LENGTH);
        BigInteger primeQ = generatePrime(BIT_LENGTH+2);

        BigInteger modulus = generateModulus(primeP, primeQ);
        BigInteger phi = generatePhi(primeP, primeQ);

        BigInteger publicExponent = generatePublicExponent(phi);
        BigInteger privateExponent = generatePrivateExponent(publicExponent, phi);

        PublicKey publicKey = new PublicKey(publicExponent);
        PrivateKey privateKey = new PrivateKey(privateExponent);

        printResults(primeP, primeQ, modulus, phi, publicExponent, privateExponent);

        return new KeyPair(publicKey, privateKey, modulus);
    }

    private static BigInteger generatePrime(int bitLength)
    {
        Random random = new MersenneTwister();
        return BigInteger.probablePrime(bitLength, random);
    }

    private static BigInteger generateModulus(BigInteger primeOne, BigInteger primeTwo)
    {
        return primeOne.multiply(primeTwo);
    }

    private static BigInteger generatePhi(BigInteger primeOne, BigInteger primeTwo)
    {
        return primeOne.subtract(BigInteger.ONE).multiply(primeTwo.subtract(BigInteger.ONE));
    }

    private static BigInteger generatePublicExponent(BigInteger phi)
    {
        for(int value : FERMAT_NUMBERS)
        {
            BigInteger fermatNumber = BigInteger.valueOf(value);
            if(phi.gcd(fermatNumber).equals(BigInteger.ONE) && phi.compareTo(fermatNumber) >= 1)
                return fermatNumber;
        }
        return BigInteger.valueOf(FERMAT_NUMBERS[0]);
    }

    private static BigInteger generatePrivateExponent(BigInteger exponent, BigInteger phi)
    {
        return exponent.modInverse(phi);
    }

    private static void printResults(BigInteger primeP, BigInteger primeQ, BigInteger modulus,
                              BigInteger phi, BigInteger publicExponent, BigInteger privateExponent)
    {
        String titleMessage = "----- Key Generation -----" +
                "\n";

        String primeMessage = String.format("Prime P: %s \nPrime Q: %s \n", primeP, primeQ) +
                "P and Q are two random prime numbers, generated through the use of the Mersenne Twister \n" +
                "pseudorandom number generator and BigInteger probablyPrime method." +
                "\n\n";

        String modulusMessage = String.format("Modulus N: %s \n", modulus) +
                "The modulus N is calculated by multiplying P by Q." +
                "\n\n";

        String phiMessage = String.format("Phi R: %s \n", phi) +
                "Phi R is calculated through the formula '(P-1) * (Q-1)'." +
                "\n\n";

        String publicKeyMessage = String.format("Public Key E: %s \n", publicExponent) +
                "The public key is generated by taking a value larger than 1 that is also smaller than R.\n" +
                "As well as this, E and R should be co-prime. The public key is also packaged with modulus N.\n" +
                "We use one of the Fermat numbers as E, selecting from: \n" +
                Arrays.toString(FERMAT_NUMBERS) +
                "\n\n";

        String privateKeyMessage = String.format("Private Key D: %s \n", privateExponent) +
                "The private key D is computed through the formula 'D * E = 1 (mod R)'." +
                "\n\n";

        String result = titleMessage + primeMessage + modulusMessage + phiMessage + publicKeyMessage + privateKeyMessage;
        System.out.println(result);
    }
}
