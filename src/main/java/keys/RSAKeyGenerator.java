package keys;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Random;

public final class RSAKeyGenerator
{
    /* Recommended minimum big length for prime numbers used in RSA as a minimum is 2048, but
     * this can be extended to 4096 if necessary.
     * The listed Fermat numbers are the only (known) primes in existence that meet the criteria
     * required to act as our public key; co-prime with phi, greater than 1 and less than phi.
     * 65537 is selected by default and is used in most cases as it is essentially fool-proof,
     * but the other options are listed should smaller numbers be required. */
    public static final short BIT_LENGTH = 2048;
    public static final int[] FERMAT_NUMBERS = {65537, 257, 17, 5, 3};

    public static KeyPair generateKeyPair()
    {
        /* Generate two prime numbers of 'similar' bit length. We adjust the second primes bit length
         * slightly by increasing it by two. This ensures that the two prime numbers will always be
         * different in size. */
        BigInteger primeP = generatePrime(BIT_LENGTH);
        BigInteger primeQ = generatePrime(BIT_LENGTH+2);

        /* Modulus and phi are very similar in calculation, as they both involve multiply the above two
         * primes together to achieve the result. However, phi is slightly different in regards to the fact
         * that before multiplication takes place, the value of each prime is reduced by 1. This ensures
         * that the value of phi is less than that of the modulus. */
        BigInteger modulus = generateModulus(primeP, primeQ);
        BigInteger phi = generatePhi(primeP, primeQ);

        /* The exponent for the public key is achieved by selecting one of the fermat numbers listed previously.
         * Again, in most cases this will be 65537. The private key exponent is generated by calculating the modular
         * inverse of the public exponent to the power of phi. */
        BigInteger publicExponent = generatePublicExponent(phi);
        BigInteger privateExponent = generatePrivateExponent(publicExponent, phi);

        /* We store the public key and private key exponents in their own objects for convenience and clarity. */
        PublicKey publicKey = new PublicKey(publicExponent);
        PrivateKey privateKey = new PrivateKey(privateExponent);
        
        /* Details the results of the key generation process to the console. Note that this is NOT visible if the
         * application was not started from the console via the JAR. */
        printResults(primeP, primeQ, modulus, phi, publicExponent, privateExponent);

        return new KeyPair(publicKey, privateKey, modulus);
    }

    private static BigInteger generatePrime(int bitLength)
    {
        Random random = new MersenneTwister();
        return BigInteger.probablePrime(bitLength, random);
    }

    private static BigInteger generateModulus(BigInteger primeOne, BigInteger primeTwo)
    {
        return primeOne.multiply(primeTwo);
    }

    private static BigInteger generatePhi(BigInteger primeOne, BigInteger primeTwo)
    {
        return primeOne.subtract(BigInteger.ONE).multiply(primeTwo.subtract(BigInteger.ONE));
    }

    private static BigInteger generatePublicExponent(BigInteger phi)
    {
        for(int value : FERMAT_NUMBERS)
        {
            BigInteger fermatNumber = BigInteger.valueOf(value);
            if(phi.gcd(fermatNumber).equals(BigInteger.ONE) && phi.compareTo(fermatNumber) >= 1)
                return fermatNumber;
        }
        return BigInteger.valueOf(FERMAT_NUMBERS[0]);
    }

    private static BigInteger generatePrivateExponent(BigInteger exponent, BigInteger phi)
    {
        return exponent.modInverse(phi);
    }

    private static void printResults(BigInteger primeP, BigInteger primeQ, BigInteger modulus,
                              BigInteger phi, BigInteger publicExponent, BigInteger privateExponent)
    {
        String titleMessage = "----- Key Generation -----" +
                "\n";

        String primeMessage = String.format("Prime P: %s \n\nPrime Q: %s \n\n", primeP, primeQ) +
                "P and Q are two random prime numbers, generated through the use of the Mersenne Twister " +
                "pseudorandom number generator and BigInteger probablyPrime method." +
                "\n\n----------\n\n";

        String modulusMessage = String.format("Modulus N: %s \n\n", modulus) +
                "The modulus N is calculated by multiplying P by Q." +
                "\n\n----------\n\n";

        String phiMessage = String.format("Phi R: %s \n\n", phi) +
                "Phi R is calculated through the formula '(P-1) * (Q-1)'." +
                "\n\n----------\n\n";

        String publicKeyMessage = String.format("Public Key E: %s \n\n", publicExponent) +
                "The public key is generated by taking a value larger than 1 that is also smaller than R. " +
                "As well as this, E and R should be co-prime. The public key is also packaged with modulus N. " +
                "We use one of the Fermat numbers as E, selecting from: \n" +
                Arrays.toString(FERMAT_NUMBERS) +
                "\n\n----------\n\n";

        String privateKeyMessage = String.format("Private Key D: %s \n\n", privateExponent) +
                "The private key D is computed through the formula 'D * E = 1 (mod R)'." +
                "\n\n----------\n\n";

        String result = titleMessage + primeMessage + modulusMessage + phiMessage + publicKeyMessage + privateKeyMessage;
        System.out.println(result);
    }
}
